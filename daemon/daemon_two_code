/*ale daemon code*/

static void daemonize(char *rundir)
{
#if SCEP_DEBUG
    int noclose=1;
#else
    int noclose=0;
#endif
    if (daemon(1, noclose) != 0) // wishing to detach themselves
       //from the controlling terminal and run in the background as system
       //daemons.
    {
       fprintf(stderr, "scepd: cannot daemonize - errno=%d\n", errno);
       exit(1);
    }
    if (rundir) chdir(rundir);
  /* Child continues */
	/*clear filemode creation mask*/
    umask(0);  //CR8018NOE-441 8018 5.20.06 scep command cannot be executed 
}
int
daemon (int nochdir, int noclose)
{
	int fd;

	switch (__fork()) {
	case -1:
		return (-1);
	case 0:
		break;
	default:
		_exit(0);
	}

	if (__setsid() == -1)
		return (-1);

	if (!nochdir)
		(void)__chdir("/");

	if (!noclose) {
		struct stat64 st;

		if ((fd = __open_nocancel(_PATH_DEVNULL, O_RDWR, 0)) != -1
		    && (__builtin_expect (__fxstat64 (_STAT_VER, fd, &st), 0)
			== 0)) {
			if (__builtin_expect (S_ISCHR (st.st_mode), 1) != 0
#if defined DEV_NULL_MAJOR && defined DEV_NULL_MINOR
			    && (st.st_rdev
				== makedev (DEV_NULL_MAJOR, DEV_NULL_MINOR))
#endif
			    ) {
				(void)__dup2(fd, STDIN_FILENO);/* Duplicate FD to FD2, closing the old FD2 and making FD2 be
   open on the same file as FD is.  Return FD2 or -1.  */

				(void)__dup2(fd, STDOUT_FILENO);
				(void)__dup2(fd, STDERR_FILENO);
				if (fd > 2)
					(void)__close (fd);
			} else {
				/* We must set an errno value since no
				   function call actually failed.  */
				__close_nocancel_nostatus (fd);
				__set_errno (ENODEV);
				return -1;
			}
		} else {
			__close_nocancel_nostatus (fd);
			return -1;
		}
	}
	return (0);
}

/*下面这个是wiring 的代码*/
void daemonise (const char *pidFile)
{
  pid_t pid ;
  int i ;
  FILE *fd ;

  syslog (LOG_DAEMON | LOG_INFO, "Becoming daemon") ;

// Fork from the parent

  if ((pid = fork ()) < 0)
  {
    syslog (LOG_DAEMON | LOG_ALERT, "Fork no. 1 failed: %m") ;
    exit (EXIT_FAILURE) ;
  }

  if (pid > 0)			// Parent - terminate
    exit (EXIT_SUCCESS) ;

// Now running on the child - become session leader

  if (setsid() < 0)
  {
    syslog (LOG_DAEMON | LOG_ALERT, "setsid failed: %m") ;
    exit (EXIT_FAILURE) ;
  }

// Ignore a few signals

  signal (SIGCHLD, SIG_IGN) ;
  signal (SIGHUP,  SIG_IGN) ;

// Fork again

  if ((pid = fork ()) < 0) //失败了
  {
    syslog (LOG_DAEMON | LOG_ALERT, "Fork no. 2 failed: %m") ;
    exit (EXIT_FAILURE) ;
  }

  if (pid > 0)			// 成功了的话，父进程不跑的
    exit (EXIT_SUCCESS) ;

// Tidying up - reset umask, change to / and close all files

  umask (0) ;	
  chdir ("/") ;

  for (i = 0 ; i < sysconf (_SC_OPEN_MAX) ; ++i)
    close (i) ;

// Write PID into /var/run

  if (pidFile != NULL)
  {
    if ((fd = fopen (pidFile, "w")) == NULL)
    {
      syslog (LOG_DAEMON | LOG_ALERT, "Unable to write PID file: %m") ;
      exit (EXIT_FAILURE) ;
    }

    fprintf (fd, "%d\n", getpid ()) ;
    fclose (fd) ;
  }
}
